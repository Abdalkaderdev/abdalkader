import { Meta } from '@storybook/blocks';

<Meta title="Guidelines/Performance" />

# Performance Optimization Guide

This guide provides comprehensive performance optimization strategies for our component library and applications.

## Overview

Performance is crucial for user experience. Our components are designed with performance in mind, but proper implementation and optimization are key to achieving optimal results.

## Core Web Vitals

Our components are optimized to meet Google's Core Web Vitals:

- **Largest Contentful Paint (LCP)**: < 2.5 seconds
- **First Input Delay (FID)**: < 100 milliseconds
- **Cumulative Layout Shift (CLS)**: < 0.1

## Bundle Size Optimization

### Tree Shaking

All components support tree shaking. Import only what you need:

```tsx
// ✅ Good - Only imports Button
import { Button } from '@abdalkader/ui';

// ❌ Bad - Imports entire library
import * as UI from '@abdalkader/ui';
```

### Code Splitting

Use dynamic imports for large components:

```tsx
// ✅ Good - Lazy load heavy components
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

### Bundle Analysis

Use our built-in bundle analyzer:

```bash
# Analyze bundle size
npm run analyze

# Check component sizes
npm run size-check
```

## Rendering Performance

### React Optimization

#### Memoization

Use `React.memo` for expensive components:

```tsx
const ExpensiveComponent = React.memo(({ data }) => {
  // Expensive rendering logic
  return <div>{data.map(item => <Item key={item.id} {...item} />)}</div>;
});
```

#### useMemo and useCallback

Optimize expensive calculations and functions:

```tsx
function DataTable({ data, onSort }) {
  // Memoize expensive calculations
  const sortedData = useMemo(() => {
    return data.sort((a, b) => a.name.localeCompare(b.name));
  }, [data]);

  // Memoize event handlers
  const handleSort = useCallback((column) => {
    onSort(column);
  }, [onSort]);

  return (
    <table>
      {sortedData.map(item => (
        <tr key={item.id}>
          <td>{item.name}</td>
        </tr>
      ))}
    </table>
  );
}
```

### Virtual Scrolling

For large lists, use virtual scrolling:

```tsx
import { FixedSizeList as List } from 'react-window';

function VirtualList({ items }) {
  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={50}
      itemData={items}
    >
      {({ index, style, data }) => (
        <div style={style}>
          {data[index].name}
        </div>
      )}
    </List>
  );
}
```

## Image Optimization

### Responsive Images

Use responsive images with proper sizing:

```tsx
function OptimizedImage({ src, alt, width, height }) {
  return (
    <img
      src={src}
      alt={alt}
      width={width}
      height={height}
      loading="lazy"
      decoding="async"
    />
  );
}
```

### WebP Format

Use modern image formats:

```tsx
function WebPImage({ src, alt }) {
  return (
    <picture>
      <source srcSet={`${src}.webp`} type="image/webp" />
      <img src={`${src}.jpg`} alt={alt} />
    </picture>
  );
}
```

## CSS Performance

### Critical CSS

Inline critical CSS for above-the-fold content:

```css
/* Critical CSS - inline in <head> */
.hero { /* Above-the-fold styles */ }
.navigation { /* Navigation styles */ }

/* Non-critical CSS - load asynchronously */
.sidebar { /* Below-the-fold styles */ }
.footer { /* Footer styles */ }
```

### CSS Optimization

- Use efficient selectors
- Avoid deep nesting (max 3 levels)
- Use CSS custom properties for theming
- Minimize repaints and reflows

```css
/* ✅ Good - Efficient selector */
.button-primary { }

/* ❌ Bad - Inefficient selector */
div > ul > li > a.button-primary { }
```

## JavaScript Performance

### Debouncing and Throttling

Optimize event handlers:

```tsx
import { debounce, throttle } from 'lodash';

function SearchInput({ onSearch }) {
  const debouncedSearch = useCallback(
    debounce((value) => onSearch(value), 300),
    [onSearch]
  );

  return (
    <Input
      onChange={(e) => debouncedSearch(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Web Workers

Use Web Workers for heavy computations:

```tsx
// worker.js
self.onmessage = function(e) {
  const { data } = e.data;
  const result = heavyComputation(data);
  self.postMessage({ result });
};

// Component
function DataProcessor({ data }) {
  const [result, setResult] = useState(null);
  const workerRef = useRef();

  useEffect(() => {
    workerRef.current = new Worker('/worker.js');
    workerRef.current.onmessage = (e) => {
      setResult(e.data.result);
    };

    return () => workerRef.current.terminate();
  }, []);

  const processData = () => {
    workerRef.current.postMessage({ data });
  };

  return (
    <div>
      <Button onClick={processData}>Process Data</Button>
      {result && <div>Result: {result}</div>}
    </div>
  );
}
```

## Network Optimization

### HTTP/2 and HTTP/3

- Use HTTP/2 for better multiplexing
- Implement HTTP/3 for reduced latency
- Enable compression (gzip/brotli)

### Caching Strategies

```typescript
// Service Worker for caching
const CACHE_NAME = 'app-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});
```

### CDN Usage

- Use CDN for static assets
- Implement proper cache headers
- Use edge caching for dynamic content

## Monitoring and Measurement

### Performance Monitoring

Track Core Web Vitals:

```tsx
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // Send to your analytics service
  console.log(metric);
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### Performance Budget

Set and monitor performance budgets:

```json
{
  "budget": [
    {
      "resourceType": "script",
      "budget": 250
    },
    {
      "resourceType": "total",
      "budget": 1000
    }
  ]
}
```

## Component-Specific Optimizations

### Button Component

- Use CSS for hover states (no JavaScript)
- Minimize re-renders with proper memoization
- Optimize touch targets for mobile

### Input Component

- Debounce validation
- Use controlled components efficiently
- Minimize DOM updates

### Form Components

- Batch form updates
- Use uncontrolled components when possible
- Implement proper error handling

## Testing Performance

### Lighthouse Audits

Run regular Lighthouse audits:

```bash
# CLI audit
lighthouse https://your-site.com --output html

# CI/CD integration
npm run lighthouse:ci
```

### Performance Testing

Use our built-in performance testing tools:

1. **Bundle Analyzer**: Check component sizes
2. **Performance Monitor**: Track runtime metrics
3. **Memory Profiler**: Identify memory leaks
4. **Network Monitor**: Analyze loading times

## Best Practices

### Development

1. **Profile First**: Measure before optimizing
2. **Optimize Critical Path**: Focus on above-the-fold content
3. **Lazy Load**: Defer non-critical resources
4. **Minimize Dependencies**: Keep bundle size small
5. **Use Production Builds**: Test with optimized code

### Production

1. **Enable Compression**: Use gzip/brotli
2. **Set Cache Headers**: Proper caching strategies
3. **Monitor Performance**: Continuous monitoring
4. **Optimize Images**: Use appropriate formats and sizes
5. **Minimize Third-Party Scripts**: Audit external dependencies

## Tools and Resources

### Performance Tools

- **Lighthouse**: Web performance auditing
- **WebPageTest**: Detailed performance analysis
- **Chrome DevTools**: Built-in performance profiling
- **Bundle Analyzer**: Bundle size analysis

### Monitoring Services

- **Google PageSpeed Insights**: Core Web Vitals monitoring
- **Web Vitals Extension**: Real-time performance metrics
- **Sentry Performance**: Application performance monitoring
- **New Relic**: Full-stack performance monitoring

## Performance Checklist

### Before Development

- [ ] Set performance budgets
- [ ] Choose appropriate tools and frameworks
- [ ] Plan for code splitting and lazy loading
- [ ] Design for mobile-first performance

### During Development

- [ ] Use performance testing tools
- [ ] Optimize images and assets
- [ ] Implement proper caching
- [ ] Monitor bundle size
- [ ] Test on slow networks

### Before Production

- [ ] Run Lighthouse audits
- [ ] Test on real devices
- [ ] Optimize critical rendering path
- [ ] Set up performance monitoring
- [ ] Configure CDN and caching

### After Production

- [ ] Monitor Core Web Vitals
- [ ] Track user experience metrics
- [ ] Analyze performance data
- [ ] Iterate and improve

## Getting Help

If you need performance optimization assistance:

1. Use the built-in performance tools
2. Check the component documentation
3. Run Lighthouse audits
4. Profile with Chrome DevTools
5. Consult the performance guidelines

Remember: Performance is an ongoing process. Regular monitoring and optimization are essential for maintaining optimal user experience.

---

*Last updated: October 2024*