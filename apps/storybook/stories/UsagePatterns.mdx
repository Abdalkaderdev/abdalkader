import { Meta } from '@storybook/blocks';

<Meta title="Guidelines/Usage Patterns" />

# Usage Patterns and Best Practices

This guide provides common usage patterns, best practices, and real-world examples for our component library.

## Overview

Understanding common usage patterns helps you build consistent, maintainable, and user-friendly interfaces. This guide covers patterns for forms, layouts, navigation, and data display.

## Form Patterns

### Basic Form Structure

```tsx
import { Button, Input } from '@abdalkader/ui';

function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      await submitForm(formData);
      // Handle success
    } catch (error) {
      setErrors(error.fieldErrors);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input
        label="Full Name"
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        error={!!errors.name}
        errorMessage={errors.name}
        required
      />
      
      <Input
        label="Email Address"
        type="email"
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        error={!!errors.email}
        errorMessage={errors.email}
        required
      />
      
      <Input
        label="Message"
        value={formData.message}
        onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}
        error={!!errors.message}
        errorMessage={errors.message}
        required
      />
      
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Send Message'}
      </Button>
    </form>
  );
}
```

### Form Validation Patterns

#### Real-time Validation

```tsx
function EmailInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  const validateEmail = (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (value && !emailRegex.test(value)) {
      setError('Please enter a valid email address');
    } else {
      setError('');
    }
  };

  return (
    <Input
      label="Email"
      type="email"
      value={email}
      onChange={(e) => {
        setEmail(e.target.value);
        validateEmail(e.target.value);
      }}
      error={!!error}
      errorMessage={error}
    />
  );
}
```

#### Debounced Validation

```tsx
import { debounce } from 'lodash';

function SearchInput({ onSearch }) {
  const [query, setQuery] = useState('');
  const [isValidating, setIsValidating] = useState(false);

  const debouncedSearch = useCallback(
    debounce(async (searchQuery) => {
      if (searchQuery.length >= 3) {
        setIsValidating(true);
        try {
          await onSearch(searchQuery);
        } finally {
          setIsValidating(false);
        }
      }
    }, 300),
    [onSearch]
  );

  useEffect(() => {
    debouncedSearch(query);
  }, [query, debouncedSearch]);

  return (
    <Input
      label="Search"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      helperText={isValidating ? 'Searching...' : 'Type at least 3 characters'}
    />
  );
}
```

### Multi-step Forms

```tsx
function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState({});
  const [errors, setErrors] = useState({});

  const steps = [
    { title: 'Personal Info', component: PersonalInfoStep },
    { title: 'Contact Details', component: ContactDetailsStep },
    { title: 'Preferences', component: PreferencesStep }
  ];

  const handleNext = () => {
    if (validateCurrentStep()) {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    setCurrentStep(prev => prev - 1);
  };

  const CurrentStepComponent = steps[currentStep].component;

  return (
    <div className="multi-step-form">
      <div className="step-indicator">
        {steps.map((step, index) => (
          <div
            key={index}
            className={`step ${index <= currentStep ? 'active' : ''}`}
          >
            {step.title}
          </div>
        ))}
      </div>
      
      <CurrentStepComponent
        data={formData}
        onChange={setFormData}
        errors={errors}
      />
      
      <div className="form-actions">
        {currentStep > 0 && (
          <Button variant="secondary" onClick={handlePrevious}>
            Previous
          </Button>
        )}
        
        {currentStep < steps.length - 1 ? (
          <Button onClick={handleNext}>
            Next
          </Button>
        ) : (
          <Button onClick={handleSubmit}>
            Submit
          </Button>
        )}
      </div>
    </div>
  );
}
```

## Layout Patterns

### Card Layout

```tsx
function CardGrid({ items }) {
  return (
    <div className="card-grid">
      {items.map(item => (
        <Card key={item.id} className="card-item">
          <CardHeader>
            <h3>{item.title}</h3>
            <Badge variant="primary">{item.category}</Badge>
          </CardHeader>
          <CardContent>
            <p>{item.description}</p>
          </CardContent>
          <CardFooter>
            <Button variant="primary">Learn More</Button>
            <Button variant="secondary">Share</Button>
          </CardFooter>
        </Card>
      ))}
    </div>
  );
}
```

### Responsive Grid

```tsx
function ResponsiveGrid({ children }) {
  return (
    <div className="responsive-grid">
      {children}
    </div>
  );
}

// CSS
.responsive-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

@media (max-width: 768px) {
  .responsive-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
}
```

### Sidebar Layout

```tsx
function SidebarLayout({ sidebar, main }) {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className="sidebar-layout">
      <aside className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
        {sidebar}
      </aside>
      
      <main className="main-content">
        <button
          className="sidebar-toggle"
          onClick={() => setSidebarOpen(!sidebarOpen)}
        >
          ☰
        </button>
        {main}
      </main>
    </div>
  );
}
```

## Navigation Patterns

### Breadcrumb Navigation

```tsx
function Breadcrumb({ items }) {
  return (
    <nav aria-label="Breadcrumb">
      <ol className="breadcrumb">
        {items.map((item, index) => (
          <li key={index} className="breadcrumb-item">
            {index === items.length - 1 ? (
              <span aria-current="page">{item.label}</span>
            ) : (
              <a href={item.href}>{item.label}</a>
            )}
            {index < items.length - 1 && <span className="separator">/</span>}
          </li>
        ))}
      </ol>
    </nav>
  );
}
```

### Tab Navigation

```tsx
function TabNavigation({ tabs, activeTab, onTabChange }) {
  return (
    <div className="tab-navigation">
      <div className="tab-list" role="tablist">
        {tabs.map(tab => (
          <button
            key={tab.id}
            className={`tab ${activeTab === tab.id ? 'active' : ''}`}
            role="tab"
            aria-selected={activeTab === tab.id}
            onClick={() => onTabChange(tab.id)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      
      <div className="tab-content">
        {tabs.find(tab => tab.id === activeTab)?.content}
      </div>
    </div>
  );
}
```

### Pagination

```tsx
function Pagination({ currentPage, totalPages, onPageChange }) {
  const getPageNumbers = () => {
    const pages = [];
    const start = Math.max(1, currentPage - 2);
    const end = Math.min(totalPages, currentPage + 2);

    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    return pages;
  };

  return (
    <nav aria-label="Pagination">
      <div className="pagination">
        <Button
          variant="secondary"
          disabled={currentPage === 1}
          onClick={() => onPageChange(currentPage - 1)}
        >
          Previous
        </Button>
        
        {getPageNumbers().map(page => (
          <Button
            key={page}
            variant={page === currentPage ? 'primary' : 'secondary'}
            onClick={() => onPageChange(page)}
          >
            {page}
          </Button>
        ))}
        
        <Button
          variant="secondary"
          disabled={currentPage === totalPages}
          onClick={() => onPageChange(currentPage + 1)}
        >
          Next
        </Button>
      </div>
    </nav>
  );
}
```

## Data Display Patterns

### Data Table

```tsx
function DataTable({ data, columns, onSort, onSelect }) {
  const [sortField, setSortField] = useState(null);
  const [sortDirection, setSortDirection] = useState('asc');
  const [selectedRows, setSelectedRows] = useState(new Set());

  const handleSort = (field) => {
    const direction = sortField === field && sortDirection === 'asc' ? 'desc' : 'asc';
    setSortField(field);
    setSortDirection(direction);
    onSort(field, direction);
  };

  const handleSelectAll = (checked) => {
    if (checked) {
      setSelectedRows(new Set(data.map(item => item.id)));
    } else {
      setSelectedRows(new Set());
    }
  };

  return (
    <div className="data-table">
      <table>
        <thead>
          <tr>
            <th>
              <input
                type="checkbox"
                checked={selectedRows.size === data.length}
                onChange={(e) => handleSelectAll(e.target.checked)}
              />
            </th>
            {columns.map(column => (
              <th
                key={column.key}
                onClick={() => handleSort(column.key)}
                className="sortable"
              >
                {column.label}
                {sortField === column.key && (
                  <span>{sortDirection === 'asc' ? '↑' : '↓'}</span>
                )}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {data.map(item => (
            <tr key={item.id}>
              <td>
                <input
                  type="checkbox"
                  checked={selectedRows.has(item.id)}
                  onChange={(e) => {
                    const newSelected = new Set(selectedRows);
                    if (e.target.checked) {
                      newSelected.add(item.id);
                    } else {
                      newSelected.delete(item.id);
                    }
                    setSelectedRows(newSelected);
                  }}
                />
              </td>
              {columns.map(column => (
                <td key={column.key}>
                  {column.render ? column.render(item[column.key], item) : item[column.key]}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

### Loading States

```tsx
function LoadingState({ isLoading, children, fallback }) {
  if (isLoading) {
    return fallback || <div className="loading-spinner">Loading...</div>;
  }
  return children;
}

// Usage
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(userData => {
      setUser(userData);
      setLoading(false);
    });
  }, [userId]);

  return (
    <LoadingState isLoading={loading}>
      <div className="user-profile">
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    </LoadingState>
  );
}
```

### Error Boundaries

```tsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>We're sorry, but something unexpected happened.</p>
          <Button onClick={() => window.location.reload()}>
            Reload Page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Accessibility Patterns

### Focus Management

```tsx
function Modal({ isOpen, onClose, children }) {
  const modalRef = useRef(null);
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
      modalRef.current?.focus();
    } else {
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="modal-overlay"
      onClick={onClose}
    >
      <div
        ref={modalRef}
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        onKeyDown={handleKeyDown}
        tabIndex={-1}
        role="dialog"
        aria-modal="true"
      >
        {children}
      </div>
    </div>
  );
}
```

### ARIA Live Regions

```tsx
function StatusMessage({ message, type = 'info' }) {
  return (
    <div
      role="alert"
      aria-live="polite"
      className={`status-message ${type}`}
    >
      {message}
    </div>
  );
}
```

## Performance Patterns

### Lazy Loading

```tsx
const LazyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

### Memoization

```tsx
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }));
  }, [data]);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onUpdate={onUpdate} />
      ))}
    </div>
  );
});
```

## Testing Patterns

### Component Testing

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@abdalkader/ui';

test('Button handles click events', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);
  
  fireEvent.click(screen.getByRole('button'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

### Integration Testing

```tsx
test('Form submission with validation', async () => {
  render(<ContactForm />);
  
  const nameInput = screen.getByLabelText(/full name/i);
  const emailInput = screen.getByLabelText(/email/i);
  const submitButton = screen.getByRole('button', { name: /send message/i });
  
  fireEvent.change(nameInput, { target: { value: 'John Doe' } });
  fireEvent.change(emailInput, { target: { value: 'john@example.com' } });
  fireEvent.click(submitButton);
  
  await waitFor(() => {
    expect(screen.getByText(/message sent/i)).toBeInTheDocument();
  });
});
```

## Common Anti-patterns to Avoid

### ❌ Don't: Inline Styles

```tsx
// Bad
<Button style={{ backgroundColor: 'red', color: 'white' }}>
  Click me
</Button>
```

### ✅ Do: Use Design Tokens

```tsx
// Good
<Button variant="danger">
  Click me
</Button>
```

### ❌ Don't: Complex State Management

```tsx
// Bad - Too much state in one component
function ComplexForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [address, setAddress] = useState('');
  // ... 20 more state variables
}
```

### ✅ Do: Use Custom Hooks

```tsx
// Good - Extract logic into custom hooks
function useFormData(initialData) {
  const [formData, setFormData] = useState(initialData);
  const [errors, setErrors] = useState({});
  
  const updateField = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };
  
  return { formData, errors, updateField };
}

function SimpleForm() {
  const { formData, errors, updateField } = useFormData({});
  // Clean component logic
}
```

## Resources

- [React Patterns](https://reactpatterns.com/)
- [Component Design Patterns](https://www.patterns.dev/)
- [Accessibility Patterns](https://www.w3.org/WAI/ARIA/apg/)
- [Performance Patterns](https://web.dev/performance/)

---

*Last updated: October 2024*